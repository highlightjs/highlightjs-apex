<!doctype html>
<html lang="en">
	<head>
		<title>Single block Apex test file</title>
		<meta charset="UTF-8" />
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
		<script charset="UTF-8" src="../dist/apex.min.js"></script>
		<link rel="stylesheet" href="./scratchpad.css" />
		<script>
			//hljs.configure({ ignoreUnescapedHTML: true, ignoreIllegals: false });
			hljs.debugMode();
			hljs.highlightAll();
		</script>
		<style>
			pre code {
				white-space: pre-wrap;
				font-size: 120%;
			}
		</style>
	</head>

	<body><pre><code>
        /*

XCode style (c) Angel Garcia <angelgarcia.mail@gmail.com>

*/

hljs {
  background: #fff;
  color: black;
}

/* Gray DOCTYPE selectors like WebKit */
.xml .hljs-meta {
  color: #c0c0c0;
}

.hljs-comment,
.hljs-quote {
  color: #007400;
}

.hljs-tag,
.hljs-attribute,
.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
#hljs-name {
  color: #aa0d91;
}

.hljs-variable,
.hljs-template-variable {
  color: #3F6E74;
}

.hljs-code,
.hljs-string,
.hljs-meta .hljs-string {
  color: #c41a16;
}

.hljs-regexp,
.hljs-link {
  color: #0E0EFF;
}

.hljs-title,
.hljs-symbol,
.hljs-bullet,
.hljs-number {
  color: #1c00cf;
}

.hljs-section,
.hljs-meta {
  color: #643820;
}


.hljs-title.class_,
.hljs-class .hljs-title,
.hljs-type,
.hljs-built_in,
.hljs-params {
  color: #5c2699;
}

.hljs-attr {
  color: #836C28;
}

.hljs-subst {
  color: #000;
}

.hljs-formula {
  background-color: #eee;
  font-style: italic;
}

.hljs-addition {
  background-color: #baeeba;
}

.hljs-deletion {
  background-color: #ffc8bd;
}

.hljs-selector-id,
.hljs-selector-class {
  color: #9b703f;
}

.hljs-doctag,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}


    </code></pre>
		<pre><code class="language-apex">
      /**
      Copyright (c) 2016, Salesforce.org
      All rights reserved.
  
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
  
      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
      * Neither the name of Salesforce.org nor the names of
        its contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
      FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
      COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
      CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
      LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
      ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
      POSSIBILITY OF SUCH DAMAGE.
  **/
  
  @SuppressWarnings('PMD.AvoidGlobalModifier, PMD.ExcessiveClassLength')
  global with sharing class VOL_SharedCode {
      @TestVisible
      private static VOL_Access access = VOL_Access.getInstance();
  
      // the list of Campaigns that have Volunteer Jobs
      global List&lt;SelectOption&gt; listSOCampaignsWithJobs {
          get {
              List&lt;SelectOption&gt; listSO = new List&lt;SelectOption&gt;();
              listSO.add(new SelectOption('', ''));
  
              // Ensure the user has access to the object before querying
              if (
                  Campaign.SObjectType.getDescribe().isAccessible() &&
                  Campaign.Name.getDescribe().isAccessible() &&
                  Campaign.IsActive.getDescribe().isAccessible() &&
                  Campaign.StartDate.getDescribe().isAccessible() &&
                  Campaign.RecordTypeId.getDescribe().isAccessible()
              ) {
                  for (Campaign c : [
                      SELECT Name, Id
                      FROM Campaign
                      WHERE RecordTypeId = :recordtypeIdVolunteersCampaign AND IsActive = TRUE
                      ORDER BY StartDate DESC, Name ASC
                      LIMIT 999
                  ]) {
                      listSO.add(new SelectOption(c.id, c.name));
                  }
              }
  
              return listSO;
          }
      }
  
      // the list of Volunteer Jobs for the specified Campaign
      global List&lt;SelectOption&gt; listSOVolunteerJobsOfCampaignId(Id campaignId) {
          List&lt;SelectOption&gt; listSO = new List&lt;SelectOption&gt;();
          listSO.add(new SelectOption('', ''));
  
          // Ensure the user has access to the object before querying
          if (
              Volunteer_Job__c.SObjectType.getDescribe().isAccessible() &&
              Volunteer_Job__c.Name.getDescribe().isAccessible() &&
              Volunteer_Job__c.Campaign__c.getDescribe().isAccessible()
          ) {
              for (Volunteer_Job__c vj : [
                  SELECT Name, Id
                  FROM Volunteer_Job__c
                  WHERE Campaign__c = :campaignId
                  ORDER BY name
                  LIMIT 999
              ]) {
                  listSO.add(new SelectOption(vj.id, vj.name));
              }
          }
          return listSO;
      }
  
      // the list of Volunteer Job Shifts for the specified Job
      global List&lt;SelectOption&gt; listSOVolunteerShiftsOfVolunteerJobId( //NOPMD
          Id volunteerJobId,
          Date dtStart,
          Date dtEnd,
          Boolean fIncludeShiftName,
          Boolean fIncludeNumberNeeded
      ) {
          return listSOVolunteerShiftsOfVolunteerJobIdFormat(
              volunteerJobId,
              dtStart,
              dtEnd,
              fIncludeShiftName,
              fIncludeNumberNeeded,
              null,
              null
          );
      }
  
      // list of select options of Shifts for the specified job, using the date & time format strings for the shifts
      public static List&lt;SelectOption&gt; listSOVolunteerShiftsOfVolunteerJobIdFormat( //NOPMD
          Id volunteerJobId,
          Date dtStart,
          Date dtEnd,
          Boolean fIncludeShiftName,
          Boolean fIncludeNumberNeeded,
          String strDateFormat,
          String strTimeFormat
      ) {
          List&lt;Volunteer_Job__c&gt; listVolunteerJobs = new List&lt;Volunteer_Job__c&gt;();
  
          List&lt;SelectOption&gt; listSO = new List&lt;SelectOption&gt;();
          listSO.add(new SelectOption('', ''));
  
          // Ensure the user has access to the object before querying
          try {
              UTIL_Describe.checkObjectReadAccess(String.valueOf(Volunteer_Shift__c.SObjectType));
          } catch (Exception ex) {
              // we will return an empty list vs throwing an error
              return listSO;
          }
  
          Boolean canReadDate = Schema.sObjectType.Volunteer_Shift__c.fields.Start_Date_Time__c.isAccessible();
          Boolean canReadNumberNeeded = Schema.sObjectType.Volunteer_Shift__c.fields.Number_of_Volunteers_Still_Needed__c.isAccessible();
  
          // ensure valid date ranges
          if (dtStart == null) {
              dtStart = System.today();
          }
          if (dtEnd == null) {
              dtEnd = System.today().addMonths(12);
          }
          dtEnd = dtEnd.addDays(1);
  
          // get our shifts in a Job query, so we can use our common date/time formatting routine.
          listVolunteerJobs = [
              SELECT
                  Id,
                  Campaign__r.IsActive,
                  Campaign__r.Volunteer_Website_Time_Zone__c,
                  Volunteer_Website_Time_Zone__c,
                  (
                      SELECT
                          Id,
                          Name,
                          Start_Date_Time__c,
                          Duration__c,
                          Number_of_Volunteers_Still_Needed__c,
                          Description__c,
                          System_Note__c
                      FROM Volunteer_Job_Slots__r
                      WHERE Start_Date_Time__c &gt;= :dtStart AND Start_Date_Time__c &lt; :dtEnd
                      ORDER BY Start_Date_Time__c
                      LIMIT 999
                  )
              FROM Volunteer_Job__c
              WHERE Id = :volunteerJobId
          ];
  
          // bail out if no jobs found
          if (listVolunteerJobs.size() == 0) {
              return listSO;
          }
  
          // whether to use our datetime formatting, or salesforce default for the current user
          Boolean useDateTimeFixup = (strDateFormat != null && strTimeFormat != null);
  
          // put correct date/time format with appropriate timezone in system note field (in memory only)
          if (useDateTimeFixup) {
              {
                  dateTimeFixup(listVolunteerJobs, strDateFormat, strTimeFormat);
              }
          }
  
          for (Volunteer_Shift__c vs : listVolunteerJobs[0].Volunteer_Job_Slots__r) {
              SelectOption so = new SelectOption(
                  vs.id,
                  (canReadDate ? (useDateTimeFixup ? vs.System_Note__c : vs.Start_Date_Time__c.format()) : '') +
                      (fIncludeShiftName ? '&nbsp;&nbsp;&nbsp;&nbsp;(' + vs.name + ')' : '') +
                      (fIncludeNumberNeeded && canReadNumberNeeded
                          ? '&nbsp;&nbsp;' +
                            (vs.Number_of_Volunteers_Still_Needed__c &gt; 0
                                ? System.Label.labelCalendarStillNeeded + vs.Number_of_Volunteers_Still_Needed__c
                                : System.Label.labelCalendarShiftFull) +
                            ' '
                          : '')
              );
              so.setEscapeItem(false);
              listSO.add(so);
          }
          return listSO;
      }
  
      // routine to go through all the shifts, and create the display
      // for the shifts start date & time - end date & time, using the appropriate
      // time zone that might be specified on the Job, Campaign, or Site Guest User.
      // Note that it stores this  in the Shift's System_Note__c field (in memory only).
      public static void dateTimeFixup(List&lt;Volunteer_Job__c&gt; listJob, String strDateFormat, String strTimeFormat) {
          // get default time zone for site guest user
          User u = [SELECT TimeZoneSidKey FROM User WHERE Id = :Userinfo.getUserId()];
  
          // javascript formatting used 'tt' for am/pm, whereas apex formatting uses 'a'.
          String strFormat = strDateFormat + ' ' + strTimeFormat.replace('tt', 'a');
          String strFormatEndTime = strTimeFormat.replace('tt', 'a');
  
          for (Volunteer_Job__c job : listJob) {
              String strTimeZone = job.Volunteer_Website_Time_Zone__c;
              if (strTimeZone == null) {
                  strTimeZone = job.Campaign__r.Volunteer_Website_Time_Zone__c;
              }
              if (strTimeZone == null) {
                  strTimeZone = u.TimeZoneSidKey;
              }
              for (Volunteer_Shift__c shift : job.Volunteer_Job_Slots__r) {
                  DateTime dtEnd = shift.Start_Date_Time__c.addMinutes(Integer.valueOf(shift.Duration__c * 60));
                  String strStart = shift.Start_Date_Time__c.format(strFormat, strTimeZone);
  
                  // see if start and end are on the same day
                  if (shift.Start_Date_Time__c.format('d', strTimeZone) == dtEnd.format('d', strTimeZone)) {
                      shift.System_Note__c = strStart + ' - ' + dtEnd.format(strFormatEndTime, strTimeZone);
                  } else {
                      shift.System_Note__c = strStart + ' - ' + dtEnd.format(strFormat, strTimeZone);
                  }
              }
          }
      }
  
      // return the GMT datetime for a datetime in the specified timezone
      public static DateTime dtGmtFromDtTimeZone(DateTime dt, TimeZone tz) {
          Integer offset = tz.getOffset(dt);
          return dt.addSeconds(-offset / 1000);
      }
  
      // Volunteer Custom Settings object.  Loads an existing, and if not found creates one with default values.
      global static Volunteers_Settings__c VolunteersSettings {
          get {
              if (VolunteersSettings == null) {
                  VolunteersSettings = Volunteers_Settings__c.getInstance();
  
                  if (VolunteersSettings.Id == null) {
                      VolunteersSettings = Volunteers_Settings__c.getOrgDefaults();
                  }
  
                  if (VolunteersSettings.Id == null) {
                      VolunteersSettings.Setupownerid = UserInfo.getOrganizationId();
  
                      // create reasonable defaults
                      VolunteersSettings.Signup_Matches_Existing_Contacts__c = false;
                      VolunteersSettings.Signup_Creates_Contacts_If_No_Match__c = false;
                      VolunteersSettings.Signup_Bucket_Account_On_Create__c = null;
                      VolunteersSettings.Recurring_Job_Future_Months__c = 4;
                      VolunteersSettings.Grant_Guest_Users_Update_Access__c = false;
                      VolunteersSettings.Contact_Match_Email_Fields__c = null;
                      VolunteersSettings.Contact_Match_First_Name_Fields__c = null;
                      VolunteersSettings.Personal_Site_Org_Wide_Email_Name__c = null;
                      VolunteersSettings.Contact_Matching_Rule__c = 'Firstname;Lastname;Email';
                      VolunteersSettings.Personal_Site_Report_Hours_Filtered__c = false;
                      if (UTIL_Describe.hasObjectCreateAccess(UTIL_Describe.StrTokenNSPrefix('Volunteers_Settings__c'))) {
                          insert VolunteersSettings;
                      }
                  } else if (VolunteersSettings.Contact_Matching_Rule__c == null) {
                      VolunteersSettings.Contact_Matching_Rule__c = 'Firstname;Lastname;Email';
                      if (UTIL_Describe.hasObjectUpdateAccess(UTIL_Describe.StrTokenNSPrefix('Volunteers_Settings__c'))) {
                          update VolunteersSettings;
                      }
                  }
              }
              return VolunteersSettings;
          }
          set;
      }
  
      // helper to get the AccoutId of the Bucket Account specified in Custom Settings.
      global static Id settingsBucketAccountId {
          get {
              if (settingsBucketAccountId == null) {
                  if (
                      VolunteersSettings.Signup_Bucket_Account_On_Create__c != null &&
                      Account.getSObjectType().getDescribe().isAccessible()
                  ) {
                      Account[] acc = [
                          SELECT Id
                          FROM Account
                          WHERE name = :VolunteersSettings.Signup_Bucket_Account_On_Create__c
                          LIMIT 1
                      ];
                      if (acc.size() &gt; 0) {
                          settingsBucketAccountId = acc[0].Id;
                      }
                  }
              }
              return settingsBucketAccountId;
          }
          set;
      }
  
      // test helper that allows one to override the users's Custom Settings with the settings we want to test with.
      global static Volunteers_Settings__c getVolunteersSettingsForTests(Volunteers_Settings__c mySettings) {
          //clear out whatever settings exist
          delete [SELECT Id FROM Volunteers_Settings__c];
          SettingsBucketAccountId = null;
  
          //create our own based on what's passed in from the test
          VolunteersSettings = new Volunteers_Settings__c(
              Signup_Matches_Existing_Contacts__c = mySettings.Signup_Matches_Existing_Contacts__c,
              Signup_Creates_Contacts_If_No_Match__c = mySettings.Signup_Creates_Contacts_If_No_Match__c,
              Signup_Bucket_Account_On_Create__c = mySettings.Signup_Bucket_Account_On_Create__c,
              Recurring_Job_Future_Months__c = mySettings.Recurring_Job_Future_Months__c,
              Contact_Match_Email_Fields__c = mySettings.Contact_Match_Email_Fields__c,
              Contact_Match_First_Name_Fields__c = mySettings.Contact_Match_First_Name_Fields__c,
              Contact_Matching_Rule__c = mySettings.Contact_Matching_Rule__c,
              Personal_Site_Org_Wide_Email_Name__c = mySettings.Personal_Site_Org_Wide_Email_Name__c,
              Personal_Site_Report_Hours_Filtered__c = mySettings.Personal_Site_Report_Hours_Filtered__c
          );
  
          insert VolunteersSettings;
          return VolunteersSettings;
      }
  
      // global helper to get the Volunteers Campaign recordtype.
      private class MyException extends Exception {
      }
      global static Id recordtypeIdVolunteersCampaign {
          get {
              if (recordtypeIdVolunteersCampaign == null) {
                  List&lt;RecordType&gt; listRT = [SELECT Id FROM RecordType WHERE DeveloperName = 'Volunteers_Campaign'];
                  if (listRT.size() == 0) {
                      throw (new MyException('The Volunteers Campaign Record Type is missing and must be restored.'));
                  }
                  recordtypeIdVolunteersCampaign = listRT[0].Id;
              }
              return recordtypeIdVolunteersCampaign;
          }
          set;
      }
  
      // shared routine to get all Fields names from the specified Field Set on Contact
      // also explicitly adds additional Contact fields that we will always use in our Sites pages.
      global static List&lt;String&gt; listStrFieldsFromContactFieldSet(Schema.FieldSet fs) {
          Set&lt;String&gt; setStrFields = new Set&lt;String&gt;();
          for (Schema.FieldSetMember f : fs.getFields()) {
              setStrFields.add(f.getFieldPath().toLowerCase());
          }
          // also add the fields we explicitly refer to in CreateOrUpdateContactFS()
          // we use a set (with lowercase) to avoid creating duplicates.
          setStrFields.add('firstname');
          setStrFields.add('lastname');
          setStrFields.add('email');
          //setStrFields.add(VOL_SharedCode.StrTokenNSPrefix('volunteer_status__c').tolowerCase());
          //setStrFields.add(VOL_SharedCode.StrTokenNSPrefix('volunteer_notes__c').toLowerCase());
          List&lt;String&gt; listStrFields = new List&lt;String&gt;();
          listStrFields.addAll(setStrFields);
          return listStrFields;
      }
  
      // shared routine to get all Fields names form the specified Field Set
      global static List&lt;String&gt; listStrFieldsFromFieldSet(Schema.FieldSet fs) {
          List&lt;String&gt; listStrFields = new List&lt;String&gt;();
          for (Schema.FieldSetMember f : fs.getFields()) {
              listStrFields.add(f.getFieldPath());
          }
          return listStrFields;
      }
  
      // global code to create a new lead or contact for web volunteer signup.
      // this code is used by both the VolunteersSignup page, and the VolunteersJobListing page.
      // it uses the custom setting for the bucket account, but takes parameters for
      // matching existing contacts, and create contacts vs. leads.  this is because the two pages have different use cases.
      // it also assumes that the contact that is passed in is the dummy record from the web page, and thus isn't real, and
      // uses the Department field to track the user's company name.
      global static Id createContactOrLead(Contact contact, Boolean fMatchExistingContacts, Boolean fCreateContacts) {
          // update the date before we start
          contact.Volunteer_Last_Web_Signup_Date__c = System.today();
  
          // let's see if we can find any matching Contacts.
          List&lt;Contact&gt; listCon = [
              SELECT
                  Id,
                  Lastname,
                  Firstname,
                  Email,
                  Phone,
                  HomePhone,
                  Volunteer_Availability__c,
                  Volunteer_Notes__c,
                  Volunteer_Last_Web_Signup_Date__c,
                  Volunteer_Status__c,
                  Volunteer_Skills__c,
                  Volunteer_Organization__c
              FROM Contact
              WHERE Lastname = :contact.Lastname AND Firstname = :contact.Firstname AND Email = :contact.Email
          ];
  
          Set&lt;String&gt; setFlds = new Set&lt;String&gt;{
              'Lastname',
              'Firstname',
              'Email',
              'Phone',
              'HomePhone',
              UTIL_Describe.StrTokenNSPrefix('Volunteer_Availability__c'),
              UTIL_Describe.StrTokenNSPrefix('Volunteer_Notes__c'),
              UTIL_Describe.StrTokenNSPrefix('Volunteer_Last_Web_Signup_Date__c'),
              UTIL_Describe.StrTokenNSPrefix('Volunteer_Status__c'),
              UTIL_Describe.StrTokenNSPrefix('Volunteer_Skills__c'),
              UTIL_Describe.StrTokenNSPrefix('Volunteer_Organization__c')
          };
  
          // if we can match existing contacts, and we found a match, update them.
          if (fMatchExistingContacts && listCon.size() &gt; 0) {
              for (Contact con : listCon) {
                  con.Volunteer_Last_Web_Signup_Date__c = contact.Volunteer_Last_Web_Signup_Date__c;
                  con.Volunteer_Availability__c = contact.Volunteer_Availability__c;
                  String strNotes = con.Volunteer_Notes__c;
                  if (strNotes != '') {
                      strNotes += '  ';
                  }
                  if (contact.Volunteer_Notes__c != null) {
                      con.Volunteer_Notes__c =
                          strNotes +
                          '[' +
                          String.valueOf(System.today()) +
                          ']: ' +
                          contact.Volunteer_Notes__c;
                  }
                  con.Volunteer_Skills__c = contact.Volunteer_Skills__c;
                  if (con.Volunteer_Status__c == null) {
                      con.Volunteer_Status__c = 'New Sign Up';
                  }
                  if (contact.Phone != null) {
                      con.Phone = contact.Phone;
                  }
                  if (contact.HomePhone != null) {
                      con.HomePhone = contact.HomePhone;
                  } // NOTE: if we find existing contact(s), we don't worry about doing anything with Company.
                  // but we can at least put it in the new Volunteer_Organization__c field.
                  if (contact.Department != null) {
                      con.Volunteer_Organization__c = contact.Department;
                  }
              }
  
              checkUpdateAccessSites('Contact', setFlds);
              access.updateRecords(listCon, dmlDuplicateOptions);
  
              return listCon[0].Id;
          } else if (fCreateContacts) {
              // No Match found, create a Contact
              contact.LeadSource = 'Web Volunteer Signup';
              contact.Volunteer_Status__c = 'New Sign Up';
  
              Account accToUse = null;
  
              // see if we can find their company (which we assume the form used Department to record.)
              if (contact.Department != null && Account.getSObjectType().getDescribe().isAccessible()) {
                  List&lt;Account&gt; listAccount = [SELECT Id, Name FROM Account WHERE Name = :contact.Department LIMIT 1];
                  if (listAccount.size() &gt; 0) {
                      accToUse = listAccount.get(0);
                  }
                  contact.Volunteer_Organization__c = contact.Department;
              }
  
              // if company found, use it
              if (accToUse != null) {
                  contact.AccountId = accToUse.Id;
              } else {
                  // otherwise use the bucket account (which may be null and imply the 1:1 model in NPSP)
                  contact.AccountId = VOL_SharedCode.SettingsBucketAccountId;
              }
              access.checkCreateAccess('Contact', setFlds);
              access.insertRecords(new List&lt;Contact&gt;{ contact }, dmlDuplicateOptions);
              return contact.Id;
          } else {
              // No Match found, create a Lead
              Lead ld = new lead();
              ld.FirstName = contact.FirstName;
              ld.LastName = contact.LastName;
              ld.Company = (contact.Department == null ? '[not provided]' : contact.Department);
              ld.Email = contact.Email;
              ld.Phone = contact.Phone;
              ld.MobilePhone = contact.HomePhone; // leads don't have a home phone!
              ld.Volunteer_Availability__c = contact.Volunteer_Availability__c;
              ld.Volunteer_Notes__c = contact.Volunteer_Notes__c;
              ld.Volunteer_Skills__c = contact.Volunteer_Skills__c;
              ld.Volunteer_Status__c = 'New Sign Up';
              ld.LeadSource = 'Web Volunteer Signup';
              UTIL_Describe.checkCreateAccess(
                  'Lead',
                  new Set&lt;String&gt;{
                      'FirstName',
                      'LastName',
                      'Company',
                      'Email',
                      'Phone',
                      'MobilePhone',
                      'LeadSource',
                      UTIL_Describe.StrTokenNSPrefix('Volunteer_Availability__c'),
                      UTIL_Describe.StrTokenNSPrefix('Volunteer_Notes__c'),
                      UTIL_Describe.StrTokenNSPrefix('Volunteer_Skills__c'),
                      UTIL_Describe.StrTokenNSPrefix('Volunteer_Status__c')
                  }
              );
              Database.insert(ld, dmlDuplicateOptions);
              return ld.Id;
          }
      }
  
      // global code to verify the passed in ContactId is valid, as well as the email
      // exists on the Contact record.
      global static Boolean isValidContactIdAndEmail(Id contactId, String strEmail) {
          if (!Contact.getSObjectType().getDescribe().isAccessible()) {
              return false;
          }
  
          String strSoql = 'SELECT Id from Contact where Id = :contactId ';
          if (VolunteersSettings.Personal_Site_Requires_URL_Email_Match__c) {
              if (strEmail == null || strEmail == '' || !Contact.Email.getDescribe().isAccessible()) {
                  return false;
              }
              strEmail = strEmail.escapeHtml4();
              strSoql += 'AND (Email = :strEmail';
              // any additional email fields to check
              Map&lt;String, SObjectField&gt; fieldByName = Contact.getSObjectType().getDescribe().fields.getMap();
              if (VolunteersSettings.Contact_Match_Email_Fields__c != null) {
                  List&lt;String&gt; listStrEmail = new List&lt;String&gt;();
                  listStrEmail = VolunteersSettings.Contact_Match_Email_Fields__c.split(';');
  
                  for (String str : listStrEmail) {
                      if (fieldByName.containsKey(str)) {
                          strSoql += ' or ' + str + ' = :strEmail ';
                      }
                  }
              }
              // handle NPSP email fields
              if (IsNPSPInstalled) {
                  if (
                      fieldByName.containsKey('npe01__AlternateEmail__c') &&
                      fieldByName.get('npe01__AlternateEmail__c').getDescribe().isAccessible()
                  ) {
                      strSoql += ' or npe01__AlternateEmail__c = :strEmail ';
                  }
                  if (
                      fieldByName.containsKey('npe01__HomeEmail__c') &&
                      fieldByName.get('npe01__HomeEmail__c').getDescribe().isAccessible()
                  ) {
                      strSoql += ' or npe01__HomeEmail__c = :strEmail ';
                  }
                  if (
                      fieldByName.containsKey('npe01__WorkEmail__c') &&
                      fieldByName.get('npe01__WorkEmail__c').getDescribe().isAccessible()
                  ) {
                      strSoql += ' or npe01__WorkEmail__c = :strEmail ';
                  }
              }
              strSoql += ') ';
          }
          List&lt;Contact&gt; listCon = Database.query(strSoql);
          return listCon.size() &gt; 0;
      }
  
      // global code to lookup an existing contact
      // listStrFields are optional fields to include in the soql call
      global static List&lt;Contact&gt; lookupContact(Contact contactRecord, List&lt;String&gt; listStrFields) {
          // let's see if we can find any matching Contacts.
          // we need to use dynamic soql, since we allow the user to modify the FieldSet of fields to edit.
          String strSoql = 'SELECT ';
          String strComma = '';
          if (listStrFields == null) {
              strSoql += 'Id';
          } else {
              for (String strF : listStrFields) {
                  strSoql += strComma + strF;
                  strComma = ', ';
              }
          }
          strSoql += ' from Contact ';
          String strAnd = ' where ';
  
          // make sure their settings haven't been completely cleared
          if (VolunteersSettings.Contact_Matching_Rule__c == null || VolunteersSettings.Contact_Matching_Rule__c == '') {
              VolunteersSettings.Contact_Matching_Rule__c = 'Firstname;Lastname;Email';
          }
          final String rule = VolunteersSettings.Contact_Matching_Rule__c;
          if (rule.containsIgnoreCase(String.valueOf(Contact.LastName))) {
              strSoql += strAnd + ' (Lastname=\'' + StrEscape(contactRecord.LastName) + '\') ';
              strAnd = ' and ';
          }
          if (rule.containsIgnoreCase(String.valueOf(Contact.FirstName))) {
              strSoql += strAnd + ' (Firstname=\'' + StrEscape(contactRecord.FirstName) + '\'';
              strAnd = ' and ';
  
              // any additional firstname fields to check
              if (VolunteersSettings.Contact_Match_First_Name_Fields__c != null) {
                  List&lt;String&gt; listStrFname = new List&lt;String&gt;();
                  listStrFname = VolunteersSettings.Contact_Match_First_Name_Fields__c.split(';');
                  for (String str : listStrFname) {
                      strSoql += ' or ' + str + '=\'' + StrEscape(contactRecord.FirstName) + '\'';
                  }
              }
              strSoql += ') ';
          }
          if (rule.containsIgnoreCase(String.valueOf(Contact.Email))) {
              strSoql += strAnd + ' (Email=\'' + contactRecord.Email + '\'';
              strAnd = ' and ';
              // any additional email fields to check
              if (VolunteersSettings.Contact_Match_Email_Fields__c != null) {
                  List&lt;String&gt; listStrEmail = new List&lt;String&gt;();
                  listStrEmail = VolunteersSettings.Contact_Match_Email_Fields__c.split(';');
                  for (String str : listStrEmail) {
                      strSoql += ' or ' + str + '=\'' + contactRecord.Email + '\'';
                  }
              }
              // handle NPSP email fields
              if (IsNPSPInstalled) {
                  strSoql += ' or npe01__AlternateEmail__c=\'' + contactRecord.Email + '\'';
                  strSoql += ' or npe01__HomeEmail__c=\'' + contactRecord.Email + '\'';
                  strSoql += ' or npe01__WorkEmail__c=\'' + contactRecord.Email + '\'';
              }
              strSoql += ') ';
          }
          strSoql += ' limit 999 ';
          List&lt;Contact&gt; listCon = Database.query(strSoql);
          return listCon;
      }
  
      // global code to create a new contact, or update an existing contact, for web volunteer signup.
      // this code is used by both the VolunteersSignupFS page, and the VolunteersJobListingFS page.
      // if creating a new Contact, it uses the custom setting for the bucket account, but takes parameters for
      // the account name to try to lookup and match.
      // It also takes the list of fields on the contact object to copy over.
      global static Id createOrUpdateContactFS( //NOPMD
          String contactIdExisting,
          Contact contact,
          String strAccountName,
          List&lt;String&gt; listStrFields
      ) {
          return CreateOrUpdateContactFS(contactIdExisting, contact, strAccountName, listStrFields, true);
      }
  
      global static Id createOrUpdateContactFS( //NOPMD
          String contactIdExisting,
          Contact contact,
          String strAccountName,
          List&lt;String&gt; listStrFields,
          Boolean setLastWebSignup
      ) {
          // listStrFields is the specific list of fields on the form's fieldset, which we should assume we want to save.
          // we also need to special case several fields we will potentially set, but we also need to know,
          // if they are in the fieldset or not.
          Set&lt;String&gt; setStrFields = new Set&lt;String&gt;();
  
          // store all fields in lower case
          for (String strField : listStrFields) {
              setStrFields.add(strField.toLowerCase());
          }
          Boolean isStatusInFS = !setStrFields.add(VOL_SharedCode.StrTokenNSPrefix('volunteer_status__c').tolowerCase());
          Boolean isNotesInFS = !setStrFields.add(VOL_SharedCode.StrTokenNSPrefix('volunteer_notes__c').toLowerCase());
  
          // create a new list with all the fields
          List&lt;String&gt; listStrFieldsAll = new List&lt;String&gt;(setStrFields);
  
          // we will check perms on the fields in this set, so remove Id
          setStrFields.remove('id');
  
          List&lt;Contact&gt; listCon = LookupContact(contact, listStrFieldsAll);
  
          // if we found a match
          if (listCon.size() &gt; 0) {
              Contact conExisting = null;
  
              // match the one that has the same Id
              if (contactIdExisting != null && contactIdExisting != '') {
                  for (Integer i = 0; i &lt; listCon.size(); i++) {
                      if (listCon[i].Id == contactIdExisting) {
                          conExisting = listCon[i];
                      }
                  }
              }
              // use first one if no match found.
              if (conExisting == null) {
                  conExisting = listCon[0];
              }
  
              // special case appending Volunteer Notes, rather than overwriting.
              if (isNotesInFS) {
                  if (
                      contact.Volunteer_Notes__c != null &&
                      contact.Volunteer_Notes__c != conExisting.Volunteer_Notes__c
                  ) {
                      contact.Volunteer_Notes__c =
                          (conExisting.Volunteer_Notes__c != null ? (conExisting.Volunteer_Notes__c + '  ') : '') +
                          '[' +
                          String.valueOf(System.today()) +
                          ']: ' +
                          contact.Volunteer_Notes__c;
                  } else {
                      contact.Volunteer_Notes__c = conExisting.Volunteer_Notes__c;
                  }
              }
  
              // special case setting Volunteer Status, only if not currently set.
              if (conExisting.Volunteer_Status__c != null) {
                  contact.Volunteer_Status__c = null;
              } else {
                  conExisting.Volunteer_Status__c = 'New Sign Up';
              }
  
              // now copy over all the non-null fields from the form's contact to the existing contact.
              // avoid overwriting existing first name or existing email, since we might match it from in a different field.
              // special case address fields
              Boolean hasMailingAddress = false;
              Boolean hasOtherAddress = false;
              for (String strF : listStrFields) {
                  strF = strF.toLowerCase();
                  // we actually still want to copy email if it is currently empty
                  if (strF == 'email' && conExisting.Email == null) {
                      conExisting.Email = contact.Email;
                      continue;
                  }
                  if (strF != 'Id' && strF != 'firstname' && strF != 'email' && contact.get(strF) != null) {
                      if (isMailingAddressField(strF)) {
                          hasMailingAddress = true;
                          continue;
                      }
                      if (isOtherAddressField(strF)) {
                          hasOtherAddress = true;
                          continue;
                      }
                      conExisting.put(strF, contact.get(strF));
                  }
              }
              if (hasMailingAddress) {
                  VOL_StateCountryPicklists.copyAddressStdSObj(contact, 'Mailing', conExisting, 'Mailing');
              }
              if (hasOtherAddress) {
                  VOL_StateCountryPicklists.copyAddressStdSObj(contact, 'Other', conExisting, 'Other');
              }
              if (setLastWebSignup) {
                  conExisting.Volunteer_Last_Web_Signup_Date__c = System.today();
              }
              checkUpdateAccessSites('Contact', setStrFields);
              access.updateRecords(new List&lt;Contact&gt;{ conExisting }, dmlDuplicateOptions);
  
              // null out notes, so another update won't append them again!
              contact.Volunteer_Notes__c = null;
              return conExisting.Id;
          } else {
              // No Match found, create a Contact
  
              // don't assume the contact object wasn't already used.
              // since we can't null out Id for the insert, copy all
              // the fields to a new object and use it.
              Contact conNew = new Contact();
              //  now copy over all the non-null fields from the form's contact to the existing contact.
              // special case address fields
              Boolean hasMailingAddress = false;
              Boolean hasOtherAddress = false;
              for (String strF : listStrFields) {
                  strF = strF.toLowerCase();
                  if (strF != 'Id' && contact.get(strF) != null) {
                      if (isMailingAddressField(strF)) {
                          hasMailingAddress = true;
                          continue;
                      }
                      if (isOtherAddressField(strF)) {
                          hasOtherAddress = true;
                          continue;
                      }
                      conNew.put(strF, contact.get(strF));
                  }
              }
              if (hasMailingAddress) {
                  VOL_StateCountryPicklists.copyAddressStdSObj(contact, 'Mailing', conNew, 'Mailing');
              }
              if (hasOtherAddress) {
                  VOL_StateCountryPicklists.copyAddressStdSObj(contact, 'Other', conNew, 'Other');
              }
              // see if we can find their company
              Account accToUse = null;
              if (strAccountName != null && Account.getSObjectType().getDescribe().isAccessible()) {
                  strAccountName = strAccountName.escapeHtml4();
                  List&lt;Account&gt; listAccount = [SELECT Id, Name FROM Account WHERE Name = :strAccountName LIMIT 1];
                  if (listAccount.size() &gt; 0) {
                      accToUse = listAccount.get(0);
                  }
              }
  
              // if company found, use it
              if (accToUse != null) {
                  conNew.AccountId = accToUse.Id;
              } else {
                  // otherwise use the bucket account (which may be null and imply the 1:1 model in NPSP)
                  conNew.AccountId = VOL_SharedCode.SettingsBucketAccountId;
              }
  
              if (setLastWebSignup) {
                  conNew.Volunteer_Last_Web_Signup_Date__c = System.today();
              }
              conNew.LeadSource = 'Web Volunteer Signup';
              conNew.Volunteer_Status__c = 'New Sign Up';
  
              access.checkCreateAccess('Contact', setStrFields);
              access.insertRecords(new List&lt;Contact&gt;{ conNew }, dmlDuplicateOptions);
  
              // null out notes, so another update won't append them again!
              contact.Volunteer_Notes__c = null;
              return conNew.Id;
          }
      }
  
      /*******************************************************************************************************
       * @description detects standard mailing address fields
       * @param strField The field to check against
       * @return Boolean True if it is a standard mailing address field, false if not.
       */
      public static Boolean isMailingAddressField(String strField) {
          return (strField.containsIgnoreCase('mailing') && !strField.endsWith('__c'));
      }
  
      /*******************************************************************************************************
       * @description detects standard other address fields
       * @param strField The field to check against
       * @return Boolean True if it is a standard other address field, false if not.
       */
      public static Boolean isOtherAddressField(String strField) {
          return (strField.containsIgnoreCase('other') &&
          !strField.endsWith('__c') &&
          !strField.equalsIgnoreCase('otherphone'));
      }
  
      // global utility to escape a .
      global static String strEscape(String str) {
          if (str == null) {
              return null;
          }
          return String.escapeSingleQuotes(str);
      }
  
      // global utility to load up an existing object and copy it to the provided object
      global static void loadAndCopyObject(Id Id, SObject sobj) {
          loadAndCopyObject(id, sobj, null);
      }
  
      public static SObject loadAndCopyObject(Id Id, SObject sobj, List&lt;String&gt; listStrFields) {
          Schema.DescribeSObjectResult des = sobj.getSObjectType().getDescribe();
  
          // if fields not provided, get all Contact fields
          if (listStrFields == null) {
              listStrFields = new List&lt;String&gt;();
              // get the fields for the object
              Map&lt;String, Schema.SObjectField&gt; mapS = des.fields.getMap().clone();
              // avoid any of the API version 30 compound fields
              // we only worry about Contact ones, since all callers are giving us contacts to copy.
              mapS.remove('mailingaddress');
              mapS.remove('otheraddress');
              listStrFields.addAll(mapS.keySet());
          }
  
          String strSoql = 'SELECT ';
          String strComma = '';
          for (String strF : listStrFields) {
              strSoql += strComma + strF;
              strComma = ', ';
          }
          strSoql += ' from ' + des.getName() + ' where Id = :id ';
          strSoql += ' limit 1';
          List&lt;SObject&gt; listSObj = Security.stripInaccessible(AccessType.READABLE, Database.query(strSoql)).getRecords();
  
          if (listSObj.size() &gt; 0) {
              SObject sobjT = listSObj[0];
              //  now copy over all the non-null fields from the form's contact to the existing contact.
              for (String strF : listStrFields) {
                  if (sobjT.get(strF) != null) {
                      try {
                          sobj.put(strF, sobjT.get(strF));
                      }
                      // prettier-ignore
                      catch (exception ex) { //NOPMD
                      }
                  }
              }
              return sobjT;
          }
          return null;
      }
  
      public static void volunteerHoursTrigger(
          List&lt;Volunteer_Hours__c&gt; listHoursOld,
          List&lt;Volunteer_Hours__c&gt; listHoursNew,
          Boolean resetTotals
      ) {
          // consider both newMap and oldMap.
          // for each hours object, there are two potential shifts it interacts with.
          // within a batch of hours changes (import scenario), multiple hours can affect the same shift.
          // thus need to keep track of the shifts to update, their original value, and the sum of their changed values.
  
          // Insert scenario: status=Confirmed or Completed. Shift &lt;&gt; null. Number of Volunteers &lt;&gt; null.
          // Delete scenario: status=Confirmed or Completed.  Shift &lt;&gt; null. Number of Volunteers &lt;&gt; null.
          // Update scenario: just treat as a delete and an insert, since we already have to handle multiple changes to same job!
  
          // WARNING: deleting, undeleting, or merging a Contact, does NOT call any trigger on the Hours!
          // thus I've manually called this from the before delete & after undelete trigger on Contacts (VOL_Contact_MaintainHours).
          Map&lt;Id, Double&gt; mpShiftIdDelta = new Map&lt;Id, Double&gt;();
  
          // first we go through the new hours, and add up the number of volunteers per shift
          if (listHoursNew != null) {
              for (Volunteer_Hours__c hr : listHoursNew) {
                  if (
                      (hr.Status__c == 'Confirmed' || hr.Status__c == 'Completed') &&
                      (hr.Volunteer_Shift__c &lt;&gt; null &&
                      hr.Number_Of_Volunteers__c != null)
                  ) {
                      Double numVols = mpShiftIdDelta.get(hr.Volunteer_Shift__c);
                      if (numVols == null) {
                          numVols = 0;
                      }
                      numVols += hr.Number_of_Volunteers__c;
                      mpShiftIdDelta.put(hr.Volunteer_Shift__c, numVols);
                  }
              }
          }
  
          // second we go through the old hours, and subtract the number of volunteers per shift
          if (listHoursOld != null) {
              for (Volunteer_Hours__c hr : listHoursOld) {
                  if (
                      (hr.Status__c == 'Confirmed' || hr.Status__c == 'Completed') &&
                      (hr.Volunteer_Shift__c &lt;&gt; null &&
                      hr.Number_Of_Volunteers__c != null)
                  ) {
                      Double numVols = mpShiftIdDelta.get(hr.Volunteer_Shift__c);
                      if (numVols == null) {
                          numVols = 0;
                      }
                      numVols -= hr.Number_of_Volunteers__c;
                      mpShiftIdDelta.put(hr.Volunteer_Shift__c, numVols);
                  }
              }
          }
  
          // bail out if nothing found (to avoid runtime error!)
          if (mpShiftIdDelta.size() == 0) {
              return;
          }
          // now that we have the Id's of the shifts, let's get them from the database, update them by the number of volunteers, and then commit.
          //List&lt;Volunteer_Shift__c&gt; listShifts = new List&lt;Volunteer_Shift__c&gt;();
          for (List&lt;Volunteer_Shift__c&gt; listShifts : [
              SELECT Id, Total_Volunteers__c
              FROM Volunteer_Shift__c
              WHERE Id IN :mpShiftIdDelta.keySet()
          ]) {
              // loop through and update them
              for (Volunteer_Shift__c shift : listShifts) {
                  Double numVols = shift.Total_Volunteers__c;
                  if (numVols == null || resetTotals) {
                      numVols = 0;
                  }
                  shift.Total_Volunteers__c = numVols + mpShiftIdDelta.get(shift.Id);
              }
              // Note: We will not check CRUD / FLS for this process so that rollups are always in sync regardless of user
              access.updateRecords(listShifts);
          }
      }
  
      // global utility used to detect whether the Non Profit Starter Pack is installed in this instance.
      private static Boolean fCheckedForNPSP = false;
      global static Boolean IsNPSPInstalled {
          get {
              if (!fCheckedForNPSP) {
                  Schema.SObjectType token = Schema.getGlobalDescribe().get('npe01__OppPayment__c');
                  IsNPSPInstalled = (token != null);
                  fCheckedForNPSP = true;
              }
              return IsNPSPInstalled;
          }
          set;
      }
  
      // global utility used to detect whether the Volunteers is running in a managed instance or unmanaged instance
      private static Boolean fCheckedForVolunteersNamespace = false;
      global static Boolean IsManagedCode {
          get {
              if (!fCheckedForVolunteersNamespace) {
                  // in order for this call to work as expected, we must be API Version 28, but we
                  // want to stay at version 25, so let's find another way!!
                  //Schema.SObjectType token = Schema.getGlobalDescribe().get('GW_Volunteers__Volunteer_Job__c');
                  //IsManagedCode = (token != null);
  
                  IsManagedCode = (getNamespace() != '');
  
                  fCheckedForVolunteersNamespace = true;
              }
              return IsManagedCode;
          }
          set;
      }
  
      /******************************************************************************************************
       * @description String helper property for getNamespace() method.
       *******************************************************************************************************/
      private static String plainNamespace;
  
      /*******************************************************************************************************
       * @description Finds the namespace for the current context.
       * @return  The current namespace as a , or a blank  if we're not in a namespaced context.
       ********************************************************************************************************/
      public static String getNamespace() {
          if (plainNamespace == null) {
              String withDotNotation = VOL_SharedCode.class.getName();
  
              if (withDotNotation.contains('.')) {
                  plainNamespace = withDotNotation.substringBefore('.');
              } else {
                  plainNamespace = '';
              }
          }
          return plainNamespace;
      }
  
      /*******************************************************************************************************
       * @description Static method that takes a string
       * If we are in a managed package, tokens in dynamic SOQL must include the package namespace prefix.
       * If you ever deploy this package as unmanaged, this routine will do nothing!
       * @param str token name
       * @return token name, with namespace prefix, if required.
       ********************************************************************************************************/
      global static String strTokenNSPrefix(String str) {
          if (getNamespace() == '') {
              return str;
          }
          str = getNamespace() + '__' + str;
          return str;
      }
  
      // utility to verify all the specified fields are accessible to the current user.
      // fields that are not accessible will have a pageMessage added to the current page
      // so the warning is displayed to the user.
      global static void testObjectFieldVisibility(String strObj, List&lt;String&gt; listStrField) {
          Map&lt;String, Schema.SObjectType&gt; gd;
          Schema.DescribeSObjectResult sobjDescr;
          Map&lt;String, Schema.SObjectField&gt; mapFieldDesc;
  
          // Obtaining the field name/token map for the object
          gd = Schema.getGlobalDescribe();
          if (gd != null) {
              sobjDescr = gd.get(strObj).getDescribe();
          }
          if (sobjDescr != null) {
              mapFieldDesc = sobjDescr.fields.getMap();
          }
          if (mapFieldDesc != null) {
              for (String strField : listStrField) {
                  // Check if the user has access on the each field
                  // note that fields in our own package must not have their prefix for the Describe Field Map
                  Schema.SObjectField fld = mapFieldDesc.get(strField.replace(StrTokenNSPrefix(''), ''));
                  if (fld != null && !fld.getDescribe().isAccessible()) {
                      ApexPages.addMessage(
                          new ApexPages.Message(
                              ApexPages.Severity.FATAL,
                              // prettier-ignore
                              'Field ' + strObj + '.' + strField + ' You need to enable field level security for this field on the Site\'s Guest User profile.'
                          )
                      );
                  }
              }
          }
      }
  
      /*******************************************************************************************************
       * @description Static method checks if running user has field update access for a set of fields
       * @param objectName the name of the object the field belongs to
       * @param fieldNames the set of field names to check update access
       * @return void
       ********************************************************************************************************/
      public static void checkUpdateAccessSites(String objectName, Set&lt;String&gt; fieldNames) {
          // for backward compatibility with 1000's of nonprofit customers, we can
          // only enforce create permissions on the Sites user for Contacts.
          if (objectName == 'Contact') {
              access.checkCreateAccess(objectName, fieldNames);
          } else {
              access.checkUpdateAccess(objectName, fieldNames);
          }
      }
  
      /**
       * @description DML options to allow overriding duplicate rules to create contacts, while throwing
       * exceptions for validation rules, required fields, etc.
       */
      private static Database.DMLOptions dmlDuplicateOptions {
          get {
              if (dmlDuplicateOptions == null) {
                  dmlDuplicateOptions = new Database.DMLOptions();
                  dmlDuplicateOptions.optAllOrNone = true;
                  dmlDuplicateOptions.DuplicateRuleHeader.allowSave = true;
              }
              return dmlDuplicateOptions;
          }
          set;
      }
  
      // This massively nested SOQL where statement looks hard coded and dumb, but as it turns out
      // there's a limit on number of campaign hierarchy levels anyway, so this isn't as dumb as it
      // seems. This method will get all campaigns in hierarchy, and keeps the logic in a single query
  
      /*******************************************************************************************************
       * @description Static method that takes an Id
       * Return a list of Campaign Ids that are children/grand-children &c of the given Campaign.
       * @param Id for any campaign
       * @return List&lt;Id&gt; of child campaigns
       ********************************************************************************************************/
      global static List&lt;Id&gt; listIdsCampaignsInHierarchy(Id campaignId) {
          Map&lt;Id, Campaign&gt; campaignsInHierarchy = new Map&lt;Id, Campaign&gt;(
              [
                  SELECT Id, Name
                  FROM Campaign
                  WHERE
                      IsActive = :true
                      AND RecordTypeId = :recordtypeIdVolunteersCampaign
                      AND (Id = :campaignId
                      OR ParentId = :campaignId
                      OR Parent.ParentId = :campaignId
                      OR Parent.Parent.ParentId = :campaignId
                      OR Parent.Parent.Parent.ParentId = :campaignId
                      OR Parent.Parent.Parent.Parent.ParentId = :campaignId)
              ]
          );
          return new List&lt;Id&gt;(campaignsInHierarchy.keySet());
      }
  
      /*******************************************************************************************************
       * @description keeps references to old labels that have been packaged, that we no longer use.
       ********************************************************************************************************/
      private static void keepUnusedLabelsInPackage() {
          String str;
          str = Label.labelCalendarConfirmed;
          str = Label.labelContactInfoRankText;
          str = Label.labelHide;
          str = Label.labelMassEmailHelp1;
          str = Label.labelMassEmailHelp2;
          str = Label.labelMassEmailHelp3;
          str = Label.labelMassEmailHelp4;
          str = Label.labelMassEmailHelp5;
          str = Label.labelMassEmailHelp6;
          str = Label.labelMassEmailHelp7;
          str = Label.labelShowHelp;
          str = Label.labelFindVolunteersCriteria;
          str = Label.labelFindVolunteersHelpAssign;
          str = Label.labelVolunteersWizardNewCampaignTitle;
          str = Label.labelContactLookupSuccess;
          str = Label.labelContactLookupNotFound;
      }
  }    
</code></pre>
	</body>
</html>
